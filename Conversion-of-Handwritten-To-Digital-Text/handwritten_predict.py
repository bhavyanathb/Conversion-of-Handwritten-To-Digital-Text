# -*- coding: utf-8 -*-
"""handwritten_predict.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1AdMOmilRAebgeRh6jF6XtPg6rYI9iuUv
"""

#importing the neccesary packages 
from keras.models import Sequential
from keras.layers import Dense, Dropout, Flatten
from keras.layers.convolutional import Conv2D
from keras.layers.convolutional import MaxPooling2D
from keras.utils import np_utils
from sklearn.model_selection import train_test_split
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import cv2

num_classes = 36

#defining model
model = Sequential()
model.add(Conv2D(32, (5, 5), input_shape=(28, 28, 1), activation='relu'))
model.add(MaxPooling2D(pool_size=(2, 2)))
model.add(Dropout(0.3))
model.add(Flatten())
model.add(Dense(64, activation='relu'))
model.add(Dense(num_classes, activation='softmax')) 
model.summary()

from google.colab import drive
drive.mount('/content/drive')

#loading the trained weights
model.load_weights('/content/drive/MyDrive/ai project/alphanumeric_with64_dense.h5')

#defining the type of loss and the optimizer
model.compile(loss='categorical_crossentropy', optimizer='adam', metrics=['accuracy'])

#if the spacing between two letters is greater than word_spacing_constant then it will detect as space
word_spacing_constant = 60 

#height_constant * height will defines the letter in which line it presents
height_constant = 1.65

#minimium height of bounding rectangle to consider it as letter
min_height = 20

#for sorting the images based on x(horizontal cordinate of rectangle) value
def takefirst(elem):
    return elem[0]

#reading the image
img_original = cv2.imread("/content/drive/MyDrive/ai project/final.jpg")

####################################################################################
#resizing image
img_original = cv2.resize(img_original,(1080,720), interpolation = cv2.INTER_AREA)
####################################################################################

#converting the rgb image to grayscale
img = cv2.cvtColor(img_original,cv2.COLOR_BGR2GRAY)

#blurring the image inorder to avoid sharp edges
img = cv2.GaussianBlur(img,(5,5),0)

#converting the grayscale image to binary based on threshold
_,img = cv2.threshold(img,127,255,cv2.THRESH_BINARY)

#inverting the image inorder to have the letters in white colour
img = cv2.bitwise_not(img)


#finding contours to the binary image
contours, hierarchy = cv2.findContours(img,cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE) 

#creating a cnt_list to store the parameters of bounding rectangle in the list
cnt_list = []
for cnt in contours:
    x,y,w,h = cv2.boundingRect(cnt)
    if (h>min_height):
      cnt_list.append((x,y,w,h))


#list for storing the resized images of each letter
img_resized = []

#created a list of 10 lists assuming number of lines is not greater than 10.
#each list stores the all the letters of the corresponding to that line
final_list = [[],[],[],[],[],[],[],[],[],[]]

#created min_y to store the y of the first line  
min_y = 2000 #initialized with 2000 which acts as max

#created max_h to store maximum height of letter
max_h = 0

#running loop to get the min_y and max_h
for val in cnt_list:
    if(val[1]<min_y):
        min_y = val[1]
    if(val[3]>max_h):
        max_h = val[3]

#running a loop in cnt_list and appending the val in the corresponding line
for val in cnt_list:
    line_no = int((val[1]-min_y)/(height_constant*max_h))
    final_list[line_no].append(val)

#sorting the elements in each line based on x value
for line_no in final_list:
    line_no.sort(key=takefirst)


for line_no in final_list:
    #count defines the count of letter in the line
    count = 0   
    for val in line_no:
        #############################################################################################################
        #drawing bounding rectangle for every contour
        img_original = cv2.rectangle(img_original,(val[0],val[1]),(val[0]+val[2],val[1]+val[3]),(0,0,255),2)
        #############################################################################################################

        #cropping the bounded rectangle and storing it in cropped_img
        cropped_img = img[val[1]:val[1]+val[3],val[0]:val[0]+val[2]]

        ########################################################################################################
        #zeropadding
        cropped_img = cv2.copyMakeBorder(cropped_img, 12, 10, 10, 10, cv2.BORDER_CONSTANT)
        ########################################################################################################
        
        #resizing the image into 28X28 
        resized = cv2.resize(cropped_img, (28,28), interpolation = cv2.INTER_AREA)


        if(count!=0):
          #midx1,midx2 are x coordinate of centroid of 2 adjacent letters
          midx1 = (2*line_no[count][0] + line_no[count][2])/2
          midx2 = (2*line_no[count-1][0] + line_no[count-1][2])/2

          #if the distance of centroids is greater than word_spacing_constant spacing is required
          if(abs(midx1-midx2)>word_spacing_constant):
            img_resized.append(np.zeros((1,1)))     #[[1]] in img_resized is placed as a symbol of space

        #appending the resized image    
        img_resized.append(resized)

        #incrementing the count
        count = count+1
    
    #[[0 0]] in img_resized is placed as a symbol of newline
    img_resized.append(np.zeros((1,2)))

#variable for storing line
line =""

#running loop on the array of images and symbols
for ind in range(len(img_resized)):

  if len(img_resized[ind][0])==1:
    #which significies a space
    line += " "
    continue

  elif len(img_resized[ind][0])==2:
    #which signifies end of line, printing the line
    print(line)
    line = ""
    continue
  
  #reshaping img to pass into model to predict
  resized_test_img = img_resized[ind].reshape(-1,28,28,1)

  #getting result from model
  result = model.predict(resized_test_img)

  #to get the index of max probability
  result = np.argmax(result, axis = 1)[0]
  

  if (result>25):
    #signifies number
    line += chr(ord('0')+result-26)
  else:
    #signifies letter
    line += chr(ord('A')+result)

